"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[434],{6714:(e,t,r)=>{function o(e,t){if(!e||"anthropic"===e)return{type:"anthropic",settings:{apiKey:t.anthropicApiKey||t.apiKey||""}};if("openrouter"===e)return{type:"openrouter",settings:{apiKey:t.openRouterApiKey||"",baseUrl:t.openRouterBaseUrl||""}};if("openai"===e)return{type:"openai",settings:{apiKey:t.openaiApiKey||"",baseUrl:t.openaiBaseUrl||"https://api.openai.com/v1",organizationId:t.openaiOrgId||""}};throw Error("Unknown provider type: ".concat(e))}function n(e){switch(e){case"anthropic":return["claude-3-opus-20240229","claude-3-sonnet-20240229","claude-3-haiku-20240307","claude-3-5-sonnet-20241022","claude-3-5-haiku-20241022"];case"openai":return["gpt-4o","gpt-4-turbo","gpt-4o-mini","gpt-4","gpt-3.5-turbo","gpt-3.5-turbo-16k"];case"openrouter":return["openai/gpt-4-turbo-preview","anthropic/claude-3-opus-20240229","anthropic/claude-3-sonnet-20240229","meta-llama/llama-2-70b-chat","google/gemini-pro"];default:return[]}}r.d(t,{SM:()=>n,Xz:()=>o})},9434:(e,t,r)=>{r.d(t,{P:()=>h});var o=r(9827),n=r(6714);let s=async()=>new Promise((e,t)=>{let r=indexedDB.open("kibitz_db",5);r.onerror=()=>t(r.error),r.onsuccess=()=>e(r.result),r.onupgradeneeded=e=>{let t=e.target.result;if(e.oldVersion<1){let e=t.createObjectStore("projects",{keyPath:"id"});e.createIndex("createdAt","createdAt"),e.createIndex("updatedAt","updatedAt"),e.createIndex("name","name"),e.createIndex("order","order"),t.createObjectStore("appState",{keyPath:"id"}),t.createObjectStore("mcpServers",{keyPath:"id"}).createIndex("name","name"),e.createIndex("settings.systemPrompt","settings.systemPrompt"),e.createIndex("conversations.name","conversations.name",{multiEntry:!0}),e.createIndex("conversations.messages.content","conversations.messages.content",{multiEntry:!0})}else if(e.oldVersion<2){let t=e.target.transaction;if(!t){console.error("No transaction available during upgrade");return}let r=t.objectStore("projects");r.indexNames.contains("order")||r.createIndex("order","order"),r.openCursor().onsuccess=e=>{let t=e.target.result;if(t){let e=t.value;"number"!=typeof e.order&&(e.order=t.key,t.update(e)),t.continue()}}}else if(e.oldVersion<3)t.createObjectStore("mcpServers",{keyPath:"id"}).createIndex("name","name");else if(e.oldVersion<4){let t=e.target.transaction;if(!t){console.error("No transaction available during upgrade");return}let r=t.objectStore("projects");r.openCursor().onsuccess=e=>{let t=e.target.result;if(t){let e=t.value;e.settings||(e.settings={mcpServers:[],model:"claude-3-5-sonnet-20241022",systemPrompt:"",elideToolResults:!1}),e.settings&&((["claude-2.0","claude-2.1","claude-2","claude-instant"].includes(e.settings.model)||!e.settings.model)&&(e.settings.model="claude-3-5-sonnet-20241022"),e.settings.provider="anthropic",e.settings.apiKey&&(e.settings.anthropicApiKey=e.settings.apiKey),e.settings.openRouterApiKey="",e.settings.openRouterBaseUrl="");try{t.update(e)}catch(r){console.error("Error updating project during migration:",r);try{t.update({...e,settings:{...e.settings,provider:"anthropic"}})}catch(e){console.error("Critical error during migration fallback:",e)}}t.continue()}},r.openCursor().onerror=e=>{console.error("Error during v4 migration:",e)}}else if(e.oldVersion<5){let t=e.target.transaction;if(!t){console.error("No transaction available during upgrade");return}let r=t.objectStore("projects");r.openCursor().onsuccess=e=>{let t=e.target.result;if(t){let e=t.value;try{e.settings&&(e.settings.providerConfig=(0,n.Xz)(e.settings.provider,e.settings),t.update(e))}catch(e){console.error("Error updating project during v5 migration:",e)}t.continue()}},r.openCursor().onerror=e=>{console.error("Error during v5 migration:",e)}}}}),a=async()=>{let e=await s();return new Promise((t,r)=>{let o=e.transaction(["projects","appState"],"readonly"),n=o.objectStore("projects"),s=o.objectStore("appState"),a=[],i={};n.index("order").openCursor().onsuccess=e=>{let t=e.target.result;t&&(a.push(t.value),t.continue())},s.get("activeIds").onsuccess=e=>{let t=e.target.result;t&&(i.activeProjectId=t.activeProjectId,i.activeConversationId=t.activeConversationId)},o.oncomplete=()=>{t({projects:a,activeProjectId:i.activeProjectId||null,activeConversationId:i.activeConversationId||null})},o.onerror=()=>r(o.error)})},i=e=>{if(e instanceof Date)return isNaN(e.getTime())?new Date().toISOString():e.toISOString();if("string"==typeof e){let t=new Date(e);return isNaN(t.getTime())?e:t.toISOString()}if("number"==typeof e){let t=new Date(e);if(!isNaN(t.getTime()))return t.toISOString()}return new Date().toISOString()},c=e=>{if(e instanceof Date&&!isNaN(e.getTime()))return e;let t=new Date(e||Date.now());return isNaN(t.getTime())?new Date:t},d=e=>{let t=JSON.parse(JSON.stringify({...e,settings:{...e.settings,mcpServerIds:e.settings.mcpServerIds||[],providerConfig:e.settings.providerConfig||(0,n.Xz)(e.settings.provider,e.settings)},conversations:e.conversations.map(e=>({...e,lastUpdated:i(e.lastUpdated),messages:e.messages.map(e=>({...e,timestamp:i(e.timestamp)}))}))}));return t.conversations=t.conversations.map(e=>({...e,lastUpdated:c(e.lastUpdated),messages:e.messages.map(e=>({...e,timestamp:c(e.timestamp)}))})),t.createdAt=c(e.createdAt),t.updatedAt=c(e.updatedAt),"number"!=typeof t.order&&(t.order=Date.now()),t},l=async e=>{let t=await s();return new Promise((r,o)=>{let n=t.transaction(["projects","appState"],"readwrite");n.objectStore("projects").clear(),e.projects.forEach(e=>{let t=d(e);n.objectStore("projects").add(t)}),n.objectStore("appState").put({id:"activeIds",activeProjectId:e.activeProjectId,activeConversationId:e.activeConversationId}),n.oncomplete=()=>r(),n.onerror=()=>o(n.error)})},p=e=>JSON.parse(JSON.stringify({...e,ws:void 0,status:"disconnected"})),v=async e=>{let t=await s();return new Promise((r,o)=>{let n=t.transaction(["mcpServers"],"readwrite"),s=n.objectStore("mcpServers");try{let t=s.clear();t.onsuccess=()=>{let t=e.map(e=>new Promise((t,r)=>{let o=p(e),n=s.add(o);n.onsuccess=()=>t(),n.onerror=()=>r(n.error)}));Promise.all(t).then(()=>r()).catch(e=>{console.error("Error saving servers:",e),o(e)})},t.onerror=e=>{console.error("Error clearing servers:",e),o(t.error)}}catch(e){console.error("Error in saveMcpServers transaction:",e),o(e)}n.onerror=()=>{console.error("Transaction error in saveMcpServers:",n.error),o(n.error)}})},u=async()=>{let e=await s();return new Promise((t,r)=>{let o=[],n=e.transaction(["mcpServers"],"readonly");n.objectStore("mcpServers").openCursor().onsuccess=e=>{let t=e.target.result;t&&(o.push(t.value),t.continue())},n.oncomplete=()=>t(o),n.onerror=()=>r(n.error)})},g=()=>Math.random().toString(36).substring(7),m={apiKey:"",groqApiKey:"",model:(e=>{switch(e){case"openai":return"gpt-4o";case"openrouter":return"openai/gpt-4-turbo-preview";default:return"claude-3-5-sonnet-20241022"}})("anthropic"),systemPrompt:"",mcpServerIds:[],elideToolResults:!1},h=(0,o.v)((e,t)=>{let r=new Map,o=new Map,n=e=>{let t=o.get(e);t&&(clearTimeout(t),o.delete(e));let n=r.get(e);n&&(n.close(),r.delete(e))},s=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3,r=o.get(e.id);r&&clearTimeout(r);let n=setTimeout(async()=>{try{await i(e)}catch(r){console.error("Reconnection failed for ".concat(e.name)),s(e,Math.min(2*t,3e4))}},t);o.set(e.id,n)},i=async o=>{try{e(e=>({servers:e.servers.map(e=>e.id===o.id?{...e,status:"connecting",error:void 0}:e)}));let a=new WebSocket(o.uri);return new Promise((i,c)=>{let d=setTimeout(()=>{a.close(),c(Error("Connection timeout"))},1e4);a.onopen=()=>{clearTimeout(d),r.set(o.id,a),a.send(JSON.stringify({jsonrpc:"2.0",method:"initialize",params:{protocolVersion:"0.1.0",clientInfo:{name:"llm-chat",version:"1.0.0"},capabilities:{tools:{}}},id:1}))},a.onclose=()=>{clearTimeout(d),n(o.id);let r={servers:t().servers.map(e=>e.id===o.id?{...e,status:"disconnected",error:"Connection closed"}:e)};e(r),v(r.servers).catch(e=>{console.error("Error saving MCP servers on disconnect:",e)}),s(o)},a.onerror=()=>{clearTimeout(d),console.log("WebSocket error (trying to reconnect...)"),n(o.id),e(e=>({servers:e.servers.map(e=>e.id===o.id?{...e,status:"error",error:"Connection error"}:e)})),s(o,0),c(Error("WebSocket connection error"))},a.onmessage=r=>{try{let n=JSON.parse(r.data);if(1===n.id)a.send(JSON.stringify({jsonrpc:"2.0",method:"notifications/initialized"})),a.send(JSON.stringify({jsonrpc:"2.0",method:"tools/list",id:2}));else if(2===n.id){if(n.error)return console.log("Received unexpected WS-MCP message:",n.results),o;let r=n.result.tools.map(e=>({...e,input_schema:e.inputSchema})),s={...o,status:"connected",error:void 0,tools:r,connection:a},c={servers:t().servers.map(e=>e.id===o.id?s:e)};e(c),v(c.servers).catch(e=>{console.error("Error saving MCP servers:",e)}),i(s)}}catch(e){return console.error("Error parsing WebSocket message"),{...o,status:"error",error:"Error parsing WebSocket message"}}}})}catch(e){return console.error("Failed to connect to server ".concat(o.name)),{...o,status:"error",error:"Failed to connect"}}};return{projects:[],activeProjectId:null,activeConversationId:null,initialized:!1,servers:[],initialize:async()=>{if(!t().initialized)try{let r=await u();console.log("Loading servers from IndexedDB:",JSON.stringify(r));let o=[];for(let e of r)try{let t=await i(e);o.push(t)}catch(t){console.error("Initial connection failed for ".concat(e.name,":"),t),o.push({...e,status:"error",error:"Failed to connect"})}if(e({servers:o}),0===r.length)try{let e=await t().attemptLocalMcpConnection();e&&(console.log("Connected to local MCP server"),await v([...o,e]))}catch(e){console.error("Failed to connect to local MCP:",e)}else await v(o);let n=await a(),s=n.projects.length>0;if(console.log("Loading projects from IndexedDB:",JSON.stringify(n)),s)e({projects:n.projects,activeProjectId:n.activeProjectId,activeConversationId:n.activeProjectId&&n.activeConversationId?n.activeConversationId:null});else{let t={id:g(),name:"(New Chat)",lastUpdated:new Date,messages:[],createdAt:new Date},r={id:g(),name:"Default Project",settings:{...m,mcpServers:[]},conversations:[t],createdAt:new Date,updatedAt:new Date,order:Date.now()};e({projects:[r],activeProjectId:r.id,activeConversationId:t.id})}e({initialized:!0})}catch(r){console.error("Error initializing data");let t={id:g(),name:"Default Project",settings:{...m,mcpServers:[]},conversations:[],createdAt:new Date,updatedAt:new Date,order:Date.now()};e({projects:[t],activeProjectId:t.id,initialized:!0})}},createProject:(r,o)=>{let{projects:n,activeProjectId:s}=t(),a=n.find(e=>e.id===s),i=g(),c=t().servers.filter(e=>"connected"===e.status).map(e=>e.id),d={id:i,name:r,settings:{...m,...a&&{apiKey:a.settings.apiKey,groqApiKey:a.settings.groqApiKey,systemPrompt:""},mcpServerIds:c,...o},conversations:[],createdAt:new Date,updatedAt:new Date,order:Math.max(...n.map(e=>e.order||0),0)+1};e(e=>({projects:[...e.projects,d],activeProjectId:i})),l({projects:[...n,d],activeProjectId:i,activeConversationId:null}).catch(e=>{console.error("Error saving state:",e)});let p=g();e(e=>({projects:e.projects.map(e=>e.id!==i?e:{...e,conversations:[{id:p,name:"(New Chat)",lastUpdated:new Date,messages:[],createdAt:new Date}],updatedAt:new Date}),activeConversationId:p}));let v=t();l({projects:v.projects,activeProjectId:v.activeProjectId,activeConversationId:v.activeConversationId}).catch(e=>{console.error("Error saving state:",e)})},deleteProject:r=>{var o,n;let{projects:s,activeProjectId:a}=t(),i=s.find(e=>e.id!==r),c={projects:s.filter(e=>e.id!==r),activeProjectId:a===r&&i?i.id:a,activeConversationId:a===r&&i?null!==(n=null===(o=i.conversations[0])||void 0===o?void 0:o.id)&&void 0!==n?n:null:t().activeConversationId};e(c),l(c).catch(e=>{console.error("Error saving state:",e)})},updateProjectSettings:(t,r)=>{e(e=>{let o={...e,projects:e.projects.map(e=>{if(e.id!==t)return e;let o=e.conversations;return r.conversations&&(o=r.conversations.map(t=>{let r=e.conversations.find(e=>e.id===t.id);return r&&"(New Chat)"!==r.name?{...t,name:r.name}:t})),{...e,settings:r.settings?{...e.settings,...r.settings,mcpServerIds:void 0!==r.settings.mcpServerIds?r.settings.mcpServerIds:e.settings.mcpServerIds}:e.settings,conversations:o,updatedAt:new Date}})};return l(o).catch(e=>{console.error("Error saving state:",e)}),o})},createConversation:(t,r)=>{let o=g();e(e=>{let n={...e,projects:e.projects.map(e=>e.id!==t?e:{...e,conversations:[{id:o,name:r||"(New Chat)",lastUpdated:new Date,createdAt:new Date,messages:[]},...e.conversations],updatedAt:new Date}),activeConversationId:o};return l(n).catch(e=>{console.error("Error saving state:",e)}),n})},deleteConversation:(t,r)=>{let o=g();e(e=>{var n,s;let a=e.projects.map(e=>{if(e.id!==t)return e;let n=e.conversations.filter(e=>e.id!==r);if(0===n.length){let t={id:o,name:"(New Chat)",lastUpdated:new Date,messages:[],createdAt:new Date};return{...e,conversations:[t],updatedAt:new Date}}return{...e,conversations:n,updatedAt:new Date}}),i=a.find(e=>e.id===t),c=(null==i?void 0:i.conversations.length)===1?o:e.activeConversationId===r?null!==(s=null==i?void 0:null===(n=i.conversations.find(e=>e.id!==r))||void 0===n?void 0:n.id)&&void 0!==s?s:null:e.activeConversationId,d={...e,projects:a,activeConversationId:c};return l(d).catch(e=>{console.error("Error saving state:",e)}),d})},renameConversation:(t,r,o)=>{"(New Chat)"!==o&&e(e=>{let n={...e,projects:e.projects.map(e=>e.id!==t?e:{...e,conversations:e.conversations.map(e=>e.id===r?{...e,name:o}:e),updatedAt:new Date})};return l(n).catch(e=>{console.error("Error saving state:",e)}),n})},renameProject:(t,r)=>{e(e=>{let o={...e,projects:e.projects.map(e=>e.id===t?{...e,name:r,updatedAt:new Date}:e)};return l(o).catch(e=>{console.error("Error saving state:",e)}),o})},setActiveProject:r=>{let{projects:o}=t(),n=r?o.find(e=>e.id===r):null;e(e=>{let t={...e,activeProjectId:r,activeConversationId:n&&n.conversations.length>0&&!e.activeConversationId?n.conversations[0].id:e.activeConversationId};return l(t).catch(e=>{console.error("Error saving state:",e)}),t})},setActiveConversation:t=>{e(e=>{let r={...e,activeConversationId:t};return l(r).catch(e=>{console.error("Error saving state:",e)}),r})},addServer:async r=>{e(e=>({servers:[...e.servers,{...r,status:"connecting",error:void 0}]}));try{let o=await i(r),n={servers:t().servers.map(e=>e.id===r.id?o:e)};return e(n),await v(n.servers),o}catch(n){let o={servers:t().servers.map(e=>e.id===r.id?{...e,status:"error",error:"Connection failed"}:e)};return e(o),v(o.servers).catch(e=>{console.error("Error saving MCP servers:",e)}),t().servers.find(e=>e.id===r.id)}},removeServer:r=>{n(r);let o={servers:t().servers.filter(e=>e.id!==r)};e(o),v(o.servers).catch(e=>{console.error("Error saving MCP servers:",e)})},reconnectServer:async r=>{let o=t().servers.find(e=>e.id===r);if(!o)throw Error("Server not found");try{let n=await i(o);return e(e=>({servers:e.servers.map(e=>e.id===r?n:e)})),await v(t().servers),n}catch(t){throw e(e=>({servers:e.servers.map(e=>e.id===r?{...e,status:"error",error:"Reconnection failed"}:e)})),Error("Failed to reconnect")}},executeTool:async(e,t,o)=>{let n=r.get(e);if(!n||n.readyState!==WebSocket.OPEN)throw Error("Server not connected");return new Promise((e,r)=>{let s=Math.random().toString(36).substring(7),a=t=>{try{let o=JSON.parse(t.data);o.id===s&&(n.removeEventListener("message",a),o.error?r(Error(o.error.message)):e(o.result.content[0].text))}catch(e){console.error("Error parsing tool response"),r(Error("Failed to parse tool response"))}};n.addEventListener("message",a),n.send(JSON.stringify({jsonrpc:"2.0",method:"tools/call",params:{name:t,arguments:o},id:s}))})},attemptLocalMcpConnection:async()=>{let r="localhost-mcp",o=window.location.protocol.endsWith("s:")?"wss":"ws",n="localhost"===window.location.hostname||"127.0.0.1"===window.location.hostname?"ws://localhost:10125":"".concat(o,"://").concat(window.location.host).concat("/fwd-ws:kibitz:nick.kino"),s=t().servers.find(e=>e.id===r);if(s)return s;try{let o=await i({id:r,name:"Local MCP",uri:n,status:"disconnected"});if("connected"===o.status)return e(e=>({servers:[...e.servers,o]})),await v(t().servers),o;return null}catch(e){return console.log("Local MCP not available"),null}}}})}}]);